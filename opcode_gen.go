// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// This is a mini version of the stringer tool.

package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
)

var (
	input  = flag.String("i", "", "input file name")
	output = flag.String("o", "", "output file name")
	pkg    = flag.String("p", "", "package name")
)

var Are = regexp.MustCompile(`^\tA([A-Z0-9]+)`)

func main() {
	flag.Parse()

	if *input == "" || *output == "" || *pkg == "" {
		flag.Usage()
		os.Exit(2)
	}

	in, err := os.Open(*input)
	if err != nil {
		log.Fatal(err)
	}
	defer in.Close()

	fd, err := os.Create(*output)
	if err != nil {
		log.Fatal(err)
	}
	defer fd.Close()

	out := bufio.NewWriter(fd)
	defer func() {
		if err := out.Flush(); err != nil {
			log.Fatal(err)
		}
	}()

	var on = false
	s := bufio.NewScanner(in)
	first := true

	for s.Scan() {
		line := s.Text()
		if !on {
			// First relevant line contains "= obj.ABase".
			// If we find it, delete the = so we don't stop immediately.
			const prefix = "= obj.ABase"
			index := strings.Index(line, prefix)
			if index < 0 {
				continue
			}

			inputPath, err := filepath.Rel(runtime.GOROOT(), *input)
			if err != nil {
				inputPath = *input
			} else {
				inputPath = filepath.Join("$GOROOT", inputPath)
			}

			// It's on. Start with the header.
			fmt.Fprintf(out, header, inputPath, *output, *pkg, *pkg)
			on = true
			line = line[:index]
		}

		// Strip comments so their text won't defeat our heuristic.
		index := strings.Index(line, "//")
		if index > 0 {
			line = line[:index]
		}

		index = strings.Index(line, "/*")
		if index > 0 {
			line = line[:index]
		}

		// Termination condition: Any line with an = changes the sequence,
		// so stop there, and stop at a closing brace.
		if strings.HasPrefix(line, "}") || strings.ContainsRune(line, '=') {
			break
		}

		sub := Are.FindStringSubmatch(line)
		if len(sub) < 2 {
			continue
		}

		if first {
			first = false
			continue
		}

		switch sub[1] {
		case "PEXTRW":
			// Golangs PEXTRW is faulty/incomplete
		default:
			fmt.Fprintf(out, "func (o Opcodes) %s%s(ops ...Operand) { o.a.op(%q, ops...) }\n", sub[1][:1], strings.ToLower(sub[1][1:]), sub[1])
			fmt.Fprintf(out, "func (o Opcodes) %[1]s(ops ...Operand) { o.a.op(%[1]q, ops...) }\n", sub[1])
		}
	}

	if s.Err() != nil {
		log.Fatal(err)
	}
}

const header = `// Generated by opcode_gen -i %s -o %s -p %s
// Do not edit.

package %s

`
